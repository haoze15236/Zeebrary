# synchronized

synchronized内置锁是一种对象锁(锁的是对象而非引用)，作用粒度是对象，可以用来实现对临界资源的同步互斥访问。

## 发展

### jdk1.6之前

jvm实现synchronized锁机制是通过给每个对象维护一个Monitor管程,而管程依赖于操作系统的Mutex互斥量，jvm要调用Mutex互斥量需要在内核态下调用Pthread库,由于jvm是运行在用户态下，因此为了调用操作系统底层库就涉及到从**用户态**到**内核态**的转换,这种转换十分的消耗性能。

### jdk1.6之后

由于1.6以前的机制性能十分低下,doug li教授一己之力实现了AQS框架(JUC包下的大部分内容),这让收购了sun公司的oracle对synchronized进行了大幅度优化:引入了偏向锁，轻量级锁,重量级锁等锁的概念,膨胀升级,提升了synchronized的性能。

## 使用

synchronized使用很简单，但是我们必须先要理解synchronized锁的粒度，在此之前要先清楚一个概念——**java中每个类(class)可以创建任意多个实例对象(instance),同时类(class)本身也是一个对象,通过`类名.class`可以获取类对象**。结合前面说的synchronized是一种对象锁,那么其锁的粒度就很好理解了。

### 锁类(class)对象

<span style="color:red">当使用sychronized锁住class对象时，该类所有new出来的实例对象(instance)也会被锁住。即无论new了多少个对象,同一时间所有对象只会有一个线程能获取到锁。</span>

#### 加锁方式

##### 锁static修饰的方法

很好理解，因为static修饰的方法或者变量，可以不用创建实例对象直接访问,这种机制的底层原理就是由于每个类都有一个类(class)对象，代码示例如下:

```java
public class JucSync {
    public static synchronized void descStock(){
		//业务代码
    }
}
```

##### 同步代码块中声明锁的类对象

```java
public class JucSync {
    public void descStock(){
        synchronized(xxx.class){
            //业务代码
        }
    }
}
```

### 锁实例对象(instance)

<span style="color:red">new出来的对象之间不互斥,同一个实例对象同一时间只会有一个线程获取到锁</span>

#### 加锁方式

##### 锁非静态方法

```java
public class JucSync {
    public synchronized void descStock(){
		//业务代码
    }
}
```

##### 同步代码块中声明锁的实例对象

```java
public class JucSync {
    public void descStock(){
        //this代表锁当前类的当前实例对象
        synchronized(this){
			//业务代码
        }
        //或者任意一个实例对象,比如锁住前面创建的test对象
        LockObject test = new LockObject();
        synchronized(test){
			//业务代码
        }
    }
}
```

## 原理

通过反编译class文件查看字节码可以发现，被sychronized修饰的代码块会有`monitorenter` 和 `monitorexit `两条指令，而被修饰的方法会有`ACC_SYNCHRONIZED`标志位，两者形式上虽然有区别，但是效果都是为了解决并发操作下的互斥与协作,其底层都是前面说到的，调用操作系统的互斥量`mutex`实现。

而在java面向对象的世界里,实际与操作系统底层交互的是一个名为monitor的对象来完成的(这也是为什么字节码指令会叫`monitorenter` 和 `monitorexit `)，前面说到sychronized是一个对象锁，是因为每个java对象都自带一个monitor对象，它存在于java对象头中

![image-20210329221926952](https://gitee.com/Zeebrary/PicBed/raw/9b97c149f3db48d8bdca9f468f7decd85e6545be/img/image-20210329221926952.png)

其中markword部分存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，它就是是**实现轻量级锁和偏向锁的关键**。其各个状态的含义如下图

![image-20210329222030298](https://gitee.com/Zeebrary/PicBed/raw/d0382fc7810e76adbd106b17f209c36ac329c136/img/image-20210329222030298.png)

### 锁的膨胀升级

锁的状态总共有四种，无锁状态、偏向锁、轻量级锁和重量级锁。随着锁的竞争，锁可以从偏向锁升级到轻量级锁，再升级的重
量级锁，但是锁的升级是单向的，也就是说只能从低到高升级，不会出现锁的降级。从JDK 1.6 中默认是开启偏向锁和轻量级锁
的，可以通过-XX:-UseBiasedLocking来禁用偏向锁。

- **偏向锁**

  偏向锁是Java 6之后加入的新锁，它是一种针对加锁操作的优化手段，经过研究发现，在大多数情况下，锁不仅不存在多线程竞
  争，而且总是由同一线程多次获得，因此为了减少同一线程获取锁(会涉及到一些CAS操作,耗时)的代价而引入偏向锁。偏向锁的核心
  思想是，如果一个线程获得了锁，那么锁就进入偏向模式，此时Mark Word 的结构也变为偏向锁结构，当这个线程再次请求锁时，
  无需再做任何同步操作，即获取锁的过程，这样就省去了大量有关锁申请的操作，从而也就提供程序的性能。所以，对于没有锁竞争
  的场合，偏向锁有很好的优化效果，毕竟极有可能连续多次是同一个线程申请相同的锁。但是对于锁竞争比较激烈的场合，偏向锁就
  失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的
  是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。下面我们接着了解轻量级锁。
  默认开启偏向锁(jvm启动时并不会马上启动,会在JVM初始化后启动,所以demo测试时可能会出现直接从无锁状态进去轻量级锁状态)
  开启偏向锁：-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0
  关闭偏向锁：-XX:-UseBiasedLocking

- **轻量级锁**

  倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)，此时
  Mark Word 的结构也变为轻量级锁的结构。轻量级锁能够提升程序性能的依据是“对绝大部分的锁，在整个同步周期内都不存在竞
  争”，注意这是经验数据。需要了解的是，轻量级锁所适应的场景是线程交替执行同步块的场合，如果存在同一时间访问同一锁的场
  合，就会导致轻量级锁膨胀为重量级锁。

- **自旋**

  轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情
  况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要
  从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线
  程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或
  100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是
  自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。
# 运行时数据区(Runtime Data Area)
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200515002440446.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzIzMTQ2MzY3,size_16,color_FFFFFF,t_70)

## 栈(stack)
栈是线程私有的，每个线程都会在内存中分配独立的栈
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200515004436711.png)
1. 栈帧
线程中的每个方法都会被分配一个栈帧
-  局部变量表：存放局部变量，若变量是对象，则存放的是对象在堆中的地址，即对象的引用
- 操作数栈：变量在计算的时候暂存的地方
- 动态链表：多态实现的基础（没太弄明白）
- 方法出口：本方法执行完后程序继续执行的地址

2. 程序计数器
多线程环境下，用于cpu执行线程快速找到上次程序执行位置
3. 本地方法栈
java代码中使用native关键字修饰的方法，实际底层一般调用的C语言实现的方法。
## 堆(Heap)
JVM调优的主要优化点
- EDEN：大部分对象被创建后存放的地方
- S0
- S1
- 老年区：持久化对象和一些大对象被创建后存放的地方
> EDEN区：S0区:S1区 内存比例一般是8：1：1
> ![在这里插入图片描述](https://img-blog.csdnimg.cn/20200515002941699.png)
### 垃圾回收机制
1.  对象被new出来之后,基本上被放在EDEN区，当EDEN区被塞满后会触发minor gc，从gc root开始扫描所有对象，非垃圾对象年龄会+1，存放在S0区，回收所有垃圾对象，清空EDEN区。

2. EDEN区第二次被塞满之后，minor gc 第二次扫描，清空EDEN区和S0区，将非垃圾对象年龄+1放入S1区。

3. EDEN区第三次被塞满之后，minor gc 第三次扫描，清空EDEN区和S1区，将非垃圾对象年龄+1放入S0区。

4. 重复2，3步骤，当对象年龄到达15时，会被移到老年区

5. 当老年区被塞满时，JVM会开始执行full gc，此时会触发STW（stop the world）暂停所有线程的执行，专注清理垃圾对象。

> STW机制是为了避免gc在扫描对象并标记完对象是否有用之后，线程执行释放对象引用，导致被gc扫描过标记为非垃圾的对象变成了垃圾对象，那么此次gc清理老年区就会存在很多垃圾对象，导致老年区清理不彻底，很快又触发full gc，长时间占用系统资源


## 方法区(Meta Space)
- 常量
- 静态变量
- 类元信息：class类的信息

